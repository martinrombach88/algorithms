It's now time for a LinkedList challenge.
I'm going to ask you to use LinkedList functionality, to create a list of places,
ordered by distance from the starting point. And we want to use a ListIterator, to move,
both backwards and forwards, through this ordered itinerary of places.
First, create a type that has a Town or place name, and a field for
storing the distance from the start. Next, create an itinerary of places
or towns to visit, much like we've been doing in the last few videos.
But this time, instead of Strings, you'll want to create a LinkedList of your place or Town type.
Here we show a list of a few places in Australia, and their distances from Sydney.
You'll create a LinkedList, ordered by the distance from
the starting point, in this case Sydney. Your start point should be the first element in your list.
And You don't want to allow duplicate places to be in your list, for this data set.
In addition, you'll create an interactive program with the following menu item options.
The menu will have options to move forwards and backwards through your itinerary,
to list the itinerary, and print menu options and quit the program.
You'll want to use a Scanner, and the nextLine method, to get input from the console.
You'll use a ListIterator, to move forwards and backwards,
through the list of places on your itinerary.


//To do:
/1.Organise list by order as a well as removing duplicates.
- Use a for loop with a distance comparison if block/ternary to organise the
- distances. The comparison should use <.

/2. Brainstorm the head and tail of the list, visualise the problem
of the moving locations before working on it more.
- Watch video 141
- Your issues:
General
You have 2 if blocks, one to set up the values of prevTown/town
and one for responding to forward = true and !last.

Combine the code into one for loop.

Head:
The Head of the list is set to 0 and 1. This works.
But you don't know the location of the iterator, so it keeps going back further
than the origin point. So the code returns 0 and 1, even after you next()
the iterator a few times.

Center:
Once you move from the right point, these lines return what you need.
// prevTown = (Town) placesToVisit.get(iterator.previousIndex());
// town = (Town) placesToVisit.get(iterator.nextIndex());
You need the iterator in the right location when traversing to keep this right.
The iterator is fine from the starting point of prevtown = 0 and town = 1.
But when you hit the end and go back, or hit back multiple times at the start,
the iterator keeps going beyond the scope of 0 and 1 / getLast / 2ndtoLast.

Tail:
getLast - 1 isn't an existing point. So to put prevTown in position of 2nd to last,
you need to find a new approach. You might consider avoiding using this position.
Can you put a limitation on how far the iterator can go?
When the iterator reaches !hasNext or !hasPrevious, can you reset it to a better position?
That's what you attempted with multiple next() / previous() calls, but this was experimentation.

Here you can see the iteration points of the iterator.
ip 1                ip 2            ip 3 ip 4 ip 5 ip 6 ip 7 ip 8 ip
it = b1, it = af1, it=b2, it=af2 . . . . . .
iterator = before 1, 1, it = after 1, it = before 2, 2, it = after 2.


/3. Don't write any more code until you have a real plan!